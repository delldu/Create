// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensor.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensor_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensor_2eproto;
namespace tensor {
class DelTensorReply;
class DelTensorReplyDefaultTypeInternal;
extern DelTensorReplyDefaultTypeInternal _DelTensorReply_default_instance_;
class DelTensorRequest;
class DelTensorRequestDefaultTypeInternal;
extern DelTensorRequestDefaultTypeInternal _DelTensorRequest_default_instance_;
class GetTensorReply;
class GetTensorReplyDefaultTypeInternal;
extern GetTensorReplyDefaultTypeInternal _GetTensorReply_default_instance_;
class GetTensorRequest;
class GetTensorRequestDefaultTypeInternal;
extern GetTensorRequestDefaultTypeInternal _GetTensorRequest_default_instance_;
class HelloReply;
class HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class ImageCleanReply;
class ImageCleanReplyDefaultTypeInternal;
extern ImageCleanReplyDefaultTypeInternal _ImageCleanReply_default_instance_;
class ImageCleanRequest;
class ImageCleanRequestDefaultTypeInternal;
extern ImageCleanRequestDefaultTypeInternal _ImageCleanRequest_default_instance_;
class ImageColorReply;
class ImageColorReplyDefaultTypeInternal;
extern ImageColorReplyDefaultTypeInternal _ImageColorReply_default_instance_;
class ImageColorRequest;
class ImageColorRequestDefaultTypeInternal;
extern ImageColorRequestDefaultTypeInternal _ImageColorRequest_default_instance_;
class ImagePatchReply;
class ImagePatchReplyDefaultTypeInternal;
extern ImagePatchReplyDefaultTypeInternal _ImagePatchReply_default_instance_;
class ImagePatchRequest;
class ImagePatchRequestDefaultTypeInternal;
extern ImagePatchRequestDefaultTypeInternal _ImagePatchRequest_default_instance_;
class ImageZoomReply;
class ImageZoomReplyDefaultTypeInternal;
extern ImageZoomReplyDefaultTypeInternal _ImageZoomReply_default_instance_;
class ImageZoomRequest;
class ImageZoomRequestDefaultTypeInternal;
extern ImageZoomRequestDefaultTypeInternal _ImageZoomRequest_default_instance_;
class SetTensorReply;
class SetTensorReplyDefaultTypeInternal;
extern SetTensorReplyDefaultTypeInternal _SetTensorReply_default_instance_;
class SetTensorRequest;
class SetTensorRequestDefaultTypeInternal;
extern SetTensorRequestDefaultTypeInternal _SetTensorRequest_default_instance_;
class Tensor;
class TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
class VideoCleanReply;
class VideoCleanReplyDefaultTypeInternal;
extern VideoCleanReplyDefaultTypeInternal _VideoCleanReply_default_instance_;
class VideoCleanRequest;
class VideoCleanRequestDefaultTypeInternal;
extern VideoCleanRequestDefaultTypeInternal _VideoCleanRequest_default_instance_;
class VideoColorReply;
class VideoColorReplyDefaultTypeInternal;
extern VideoColorReplyDefaultTypeInternal _VideoColorReply_default_instance_;
class VideoColorRequest;
class VideoColorRequestDefaultTypeInternal;
extern VideoColorRequestDefaultTypeInternal _VideoColorRequest_default_instance_;
class VideoSlowReply;
class VideoSlowReplyDefaultTypeInternal;
extern VideoSlowReplyDefaultTypeInternal _VideoSlowReply_default_instance_;
class VideoSlowRequest;
class VideoSlowRequestDefaultTypeInternal;
extern VideoSlowRequestDefaultTypeInternal _VideoSlowRequest_default_instance_;
class VideoZoomReply;
class VideoZoomReplyDefaultTypeInternal;
extern VideoZoomReplyDefaultTypeInternal _VideoZoomReply_default_instance_;
class VideoZoomRequest;
class VideoZoomRequestDefaultTypeInternal;
extern VideoZoomRequestDefaultTypeInternal _VideoZoomRequest_default_instance_;
}  // namespace tensor
PROTOBUF_NAMESPACE_OPEN
template<> ::tensor::DelTensorReply* Arena::CreateMaybeMessage<::tensor::DelTensorReply>(Arena*);
template<> ::tensor::DelTensorRequest* Arena::CreateMaybeMessage<::tensor::DelTensorRequest>(Arena*);
template<> ::tensor::GetTensorReply* Arena::CreateMaybeMessage<::tensor::GetTensorReply>(Arena*);
template<> ::tensor::GetTensorRequest* Arena::CreateMaybeMessage<::tensor::GetTensorRequest>(Arena*);
template<> ::tensor::HelloReply* Arena::CreateMaybeMessage<::tensor::HelloReply>(Arena*);
template<> ::tensor::HelloRequest* Arena::CreateMaybeMessage<::tensor::HelloRequest>(Arena*);
template<> ::tensor::ImageCleanReply* Arena::CreateMaybeMessage<::tensor::ImageCleanReply>(Arena*);
template<> ::tensor::ImageCleanRequest* Arena::CreateMaybeMessage<::tensor::ImageCleanRequest>(Arena*);
template<> ::tensor::ImageColorReply* Arena::CreateMaybeMessage<::tensor::ImageColorReply>(Arena*);
template<> ::tensor::ImageColorRequest* Arena::CreateMaybeMessage<::tensor::ImageColorRequest>(Arena*);
template<> ::tensor::ImagePatchReply* Arena::CreateMaybeMessage<::tensor::ImagePatchReply>(Arena*);
template<> ::tensor::ImagePatchRequest* Arena::CreateMaybeMessage<::tensor::ImagePatchRequest>(Arena*);
template<> ::tensor::ImageZoomReply* Arena::CreateMaybeMessage<::tensor::ImageZoomReply>(Arena*);
template<> ::tensor::ImageZoomRequest* Arena::CreateMaybeMessage<::tensor::ImageZoomRequest>(Arena*);
template<> ::tensor::SetTensorReply* Arena::CreateMaybeMessage<::tensor::SetTensorReply>(Arena*);
template<> ::tensor::SetTensorRequest* Arena::CreateMaybeMessage<::tensor::SetTensorRequest>(Arena*);
template<> ::tensor::Tensor* Arena::CreateMaybeMessage<::tensor::Tensor>(Arena*);
template<> ::tensor::VideoCleanReply* Arena::CreateMaybeMessage<::tensor::VideoCleanReply>(Arena*);
template<> ::tensor::VideoCleanRequest* Arena::CreateMaybeMessage<::tensor::VideoCleanRequest>(Arena*);
template<> ::tensor::VideoColorReply* Arena::CreateMaybeMessage<::tensor::VideoColorReply>(Arena*);
template<> ::tensor::VideoColorRequest* Arena::CreateMaybeMessage<::tensor::VideoColorRequest>(Arena*);
template<> ::tensor::VideoSlowReply* Arena::CreateMaybeMessage<::tensor::VideoSlowReply>(Arena*);
template<> ::tensor::VideoSlowRequest* Arena::CreateMaybeMessage<::tensor::VideoSlowRequest>(Arena*);
template<> ::tensor::VideoZoomReply* Arena::CreateMaybeMessage<::tensor::VideoZoomReply>(Arena*);
template<> ::tensor::VideoZoomRequest* Arena::CreateMaybeMessage<::tensor::VideoZoomRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensor {

// ===================================================================

class HelloRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {};
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return CreateMaybeMessage<HelloRequest>(nullptr);
  }

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:tensor.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class HelloReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.HelloReply) */ {
 public:
  inline HelloReply() : HelloReply(nullptr) {};
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const final {
    return CreateMaybeMessage<HelloReply>(nullptr);
  }

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.HelloReply";
  }
  protected:
  explicit HelloReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.HelloReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class Tensor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {};
  virtual ~Tensor();

  Tensor(const Tensor& from);
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tensor* New() const final {
    return CreateMaybeMessage<Tensor>(nullptr);
  }

  Tensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tensor& from);
  void MergeFrom(const Tensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.Tensor";
  }
  protected:
  explicit Tensor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kNFieldNumber = 1,
    kCFieldNumber = 2,
    kHFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 N = 1;
  void clear_n();
  ::PROTOBUF_NAMESPACE_ID::int32 n() const;
  void set_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_n() const;
  void _internal_set_n(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 C = 2;
  void clear_c();
  ::PROTOBUF_NAMESPACE_ID::int32 c() const;
  void set_c(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_c() const;
  void _internal_set_c(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 H = 3;
  void clear_h();
  ::PROTOBUF_NAMESPACE_ID::int32 h() const;
  void set_h(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_h() const;
  void _internal_set_h(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 W = 4;
  void clear_w();
  ::PROTOBUF_NAMESPACE_ID::int32 w() const;
  void set_w(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_w() const;
  void _internal_set_w(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:tensor.Tensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 n_;
  ::PROTOBUF_NAMESPACE_ID::int32 c_;
  ::PROTOBUF_NAMESPACE_ID::int32 h_;
  ::PROTOBUF_NAMESPACE_ID::int32 w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class SetTensorRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.SetTensorRequest) */ {
 public:
  inline SetTensorRequest() : SetTensorRequest(nullptr) {};
  virtual ~SetTensorRequest();

  SetTensorRequest(const SetTensorRequest& from);
  SetTensorRequest(SetTensorRequest&& from) noexcept
    : SetTensorRequest() {
    *this = ::std::move(from);
  }

  inline SetTensorRequest& operator=(const SetTensorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTensorRequest& operator=(SetTensorRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetTensorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetTensorRequest* internal_default_instance() {
    return reinterpret_cast<const SetTensorRequest*>(
               &_SetTensorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetTensorRequest& a, SetTensorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTensorRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTensorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetTensorRequest* New() const final {
    return CreateMaybeMessage<SetTensorRequest>(nullptr);
  }

  SetTensorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetTensorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetTensorRequest& from);
  void MergeFrom(const SetTensorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTensorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.SetTensorRequest";
  }
  protected:
  explicit SetTensorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTensorFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .tensor.Tensor tensor = 2;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::tensor::Tensor& tensor() const;
  ::tensor::Tensor* release_tensor();
  ::tensor::Tensor* mutable_tensor();
  void set_allocated_tensor(::tensor::Tensor* tensor);
  private:
  const ::tensor::Tensor& _internal_tensor() const;
  ::tensor::Tensor* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::tensor::Tensor* tensor);
  ::tensor::Tensor* unsafe_arena_release_tensor();

  // @@protoc_insertion_point(class_scope:tensor.SetTensorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::tensor::Tensor* tensor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class SetTensorReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.SetTensorReply) */ {
 public:
  inline SetTensorReply() : SetTensorReply(nullptr) {};
  virtual ~SetTensorReply();

  SetTensorReply(const SetTensorReply& from);
  SetTensorReply(SetTensorReply&& from) noexcept
    : SetTensorReply() {
    *this = ::std::move(from);
  }

  inline SetTensorReply& operator=(const SetTensorReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTensorReply& operator=(SetTensorReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetTensorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetTensorReply* internal_default_instance() {
    return reinterpret_cast<const SetTensorReply*>(
               &_SetTensorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetTensorReply& a, SetTensorReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTensorReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTensorReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetTensorReply* New() const final {
    return CreateMaybeMessage<SetTensorReply>(nullptr);
  }

  SetTensorReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetTensorReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetTensorReply& from);
  void MergeFrom(const SetTensorReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTensorReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.SetTensorReply";
  }
  protected:
  explicit SetTensorReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.SetTensorReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class GetTensorRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.GetTensorRequest) */ {
 public:
  inline GetTensorRequest() : GetTensorRequest(nullptr) {};
  virtual ~GetTensorRequest();

  GetTensorRequest(const GetTensorRequest& from);
  GetTensorRequest(GetTensorRequest&& from) noexcept
    : GetTensorRequest() {
    *this = ::std::move(from);
  }

  inline GetTensorRequest& operator=(const GetTensorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTensorRequest& operator=(GetTensorRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTensorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTensorRequest* internal_default_instance() {
    return reinterpret_cast<const GetTensorRequest*>(
               &_GetTensorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetTensorRequest& a, GetTensorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTensorRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTensorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTensorRequest* New() const final {
    return CreateMaybeMessage<GetTensorRequest>(nullptr);
  }

  GetTensorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTensorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTensorRequest& from);
  void MergeFrom(const GetTensorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTensorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.GetTensorRequest";
  }
  protected:
  explicit GetTensorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.GetTensorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class GetTensorReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.GetTensorReply) */ {
 public:
  inline GetTensorReply() : GetTensorReply(nullptr) {};
  virtual ~GetTensorReply();

  GetTensorReply(const GetTensorReply& from);
  GetTensorReply(GetTensorReply&& from) noexcept
    : GetTensorReply() {
    *this = ::std::move(from);
  }

  inline GetTensorReply& operator=(const GetTensorReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTensorReply& operator=(GetTensorReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetTensorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTensorReply* internal_default_instance() {
    return reinterpret_cast<const GetTensorReply*>(
               &_GetTensorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetTensorReply& a, GetTensorReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTensorReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTensorReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTensorReply* New() const final {
    return CreateMaybeMessage<GetTensorReply>(nullptr);
  }

  GetTensorReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTensorReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetTensorReply& from);
  void MergeFrom(const GetTensorReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTensorReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.GetTensorReply";
  }
  protected:
  explicit GetTensorReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorFieldNumber = 1,
  };
  // .tensor.Tensor tensor = 1;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::tensor::Tensor& tensor() const;
  ::tensor::Tensor* release_tensor();
  ::tensor::Tensor* mutable_tensor();
  void set_allocated_tensor(::tensor::Tensor* tensor);
  private:
  const ::tensor::Tensor& _internal_tensor() const;
  ::tensor::Tensor* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::tensor::Tensor* tensor);
  ::tensor::Tensor* unsafe_arena_release_tensor();

  // @@protoc_insertion_point(class_scope:tensor.GetTensorReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensor::Tensor* tensor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class DelTensorRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.DelTensorRequest) */ {
 public:
  inline DelTensorRequest() : DelTensorRequest(nullptr) {};
  virtual ~DelTensorRequest();

  DelTensorRequest(const DelTensorRequest& from);
  DelTensorRequest(DelTensorRequest&& from) noexcept
    : DelTensorRequest() {
    *this = ::std::move(from);
  }

  inline DelTensorRequest& operator=(const DelTensorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelTensorRequest& operator=(DelTensorRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelTensorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelTensorRequest* internal_default_instance() {
    return reinterpret_cast<const DelTensorRequest*>(
               &_DelTensorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DelTensorRequest& a, DelTensorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DelTensorRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelTensorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelTensorRequest* New() const final {
    return CreateMaybeMessage<DelTensorRequest>(nullptr);
  }

  DelTensorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelTensorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelTensorRequest& from);
  void MergeFrom(const DelTensorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelTensorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.DelTensorRequest";
  }
  protected:
  explicit DelTensorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.DelTensorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class DelTensorReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.DelTensorReply) */ {
 public:
  inline DelTensorReply() : DelTensorReply(nullptr) {};
  virtual ~DelTensorReply();

  DelTensorReply(const DelTensorReply& from);
  DelTensorReply(DelTensorReply&& from) noexcept
    : DelTensorReply() {
    *this = ::std::move(from);
  }

  inline DelTensorReply& operator=(const DelTensorReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelTensorReply& operator=(DelTensorReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelTensorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelTensorReply* internal_default_instance() {
    return reinterpret_cast<const DelTensorReply*>(
               &_DelTensorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DelTensorReply& a, DelTensorReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DelTensorReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelTensorReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelTensorReply* New() const final {
    return CreateMaybeMessage<DelTensorReply>(nullptr);
  }

  DelTensorReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelTensorReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelTensorReply& from);
  void MergeFrom(const DelTensorReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelTensorReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.DelTensorReply";
  }
  protected:
  explicit DelTensorReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.DelTensorReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageCleanRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageCleanRequest) */ {
 public:
  inline ImageCleanRequest() : ImageCleanRequest(nullptr) {};
  virtual ~ImageCleanRequest();

  ImageCleanRequest(const ImageCleanRequest& from);
  ImageCleanRequest(ImageCleanRequest&& from) noexcept
    : ImageCleanRequest() {
    *this = ::std::move(from);
  }

  inline ImageCleanRequest& operator=(const ImageCleanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCleanRequest& operator=(ImageCleanRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageCleanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageCleanRequest* internal_default_instance() {
    return reinterpret_cast<const ImageCleanRequest*>(
               &_ImageCleanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ImageCleanRequest& a, ImageCleanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCleanRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCleanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageCleanRequest* New() const final {
    return CreateMaybeMessage<ImageCleanRequest>(nullptr);
  }

  ImageCleanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageCleanRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageCleanRequest& from);
  void MergeFrom(const ImageCleanRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCleanRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageCleanRequest";
  }
  protected:
  explicit ImageCleanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageCleanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageCleanReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageCleanReply) */ {
 public:
  inline ImageCleanReply() : ImageCleanReply(nullptr) {};
  virtual ~ImageCleanReply();

  ImageCleanReply(const ImageCleanReply& from);
  ImageCleanReply(ImageCleanReply&& from) noexcept
    : ImageCleanReply() {
    *this = ::std::move(from);
  }

  inline ImageCleanReply& operator=(const ImageCleanReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCleanReply& operator=(ImageCleanReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageCleanReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageCleanReply* internal_default_instance() {
    return reinterpret_cast<const ImageCleanReply*>(
               &_ImageCleanReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ImageCleanReply& a, ImageCleanReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCleanReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCleanReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageCleanReply* New() const final {
    return CreateMaybeMessage<ImageCleanReply>(nullptr);
  }

  ImageCleanReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageCleanReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageCleanReply& from);
  void MergeFrom(const ImageCleanReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCleanReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageCleanReply";
  }
  protected:
  explicit ImageCleanReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageCleanReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageColorRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageColorRequest) */ {
 public:
  inline ImageColorRequest() : ImageColorRequest(nullptr) {};
  virtual ~ImageColorRequest();

  ImageColorRequest(const ImageColorRequest& from);
  ImageColorRequest(ImageColorRequest&& from) noexcept
    : ImageColorRequest() {
    *this = ::std::move(from);
  }

  inline ImageColorRequest& operator=(const ImageColorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageColorRequest& operator=(ImageColorRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageColorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageColorRequest* internal_default_instance() {
    return reinterpret_cast<const ImageColorRequest*>(
               &_ImageColorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ImageColorRequest& a, ImageColorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageColorRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageColorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageColorRequest* New() const final {
    return CreateMaybeMessage<ImageColorRequest>(nullptr);
  }

  ImageColorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageColorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageColorRequest& from);
  void MergeFrom(const ImageColorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageColorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageColorRequest";
  }
  protected:
  explicit ImageColorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
    kRidFieldNumber = 3,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  void set_rid(const std::string& value);
  void set_rid(std::string&& value);
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  std::string* mutable_rid();
  std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rid(
      std::string* rid);
  private:
  const std::string& _internal_rid() const;
  void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageColorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageColorReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageColorReply) */ {
 public:
  inline ImageColorReply() : ImageColorReply(nullptr) {};
  virtual ~ImageColorReply();

  ImageColorReply(const ImageColorReply& from);
  ImageColorReply(ImageColorReply&& from) noexcept
    : ImageColorReply() {
    *this = ::std::move(from);
  }

  inline ImageColorReply& operator=(const ImageColorReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageColorReply& operator=(ImageColorReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageColorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageColorReply* internal_default_instance() {
    return reinterpret_cast<const ImageColorReply*>(
               &_ImageColorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ImageColorReply& a, ImageColorReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageColorReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageColorReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageColorReply* New() const final {
    return CreateMaybeMessage<ImageColorReply>(nullptr);
  }

  ImageColorReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageColorReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageColorReply& from);
  void MergeFrom(const ImageColorReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageColorReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageColorReply";
  }
  protected:
  explicit ImageColorReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageColorReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageZoomRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageZoomRequest) */ {
 public:
  inline ImageZoomRequest() : ImageZoomRequest(nullptr) {};
  virtual ~ImageZoomRequest();

  ImageZoomRequest(const ImageZoomRequest& from);
  ImageZoomRequest(ImageZoomRequest&& from) noexcept
    : ImageZoomRequest() {
    *this = ::std::move(from);
  }

  inline ImageZoomRequest& operator=(const ImageZoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageZoomRequest& operator=(ImageZoomRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageZoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageZoomRequest* internal_default_instance() {
    return reinterpret_cast<const ImageZoomRequest*>(
               &_ImageZoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ImageZoomRequest& a, ImageZoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageZoomRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageZoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageZoomRequest* New() const final {
    return CreateMaybeMessage<ImageZoomRequest>(nullptr);
  }

  ImageZoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageZoomRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageZoomRequest& from);
  void MergeFrom(const ImageZoomRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageZoomRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageZoomRequest";
  }
  protected:
  explicit ImageZoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageZoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImageZoomReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImageZoomReply) */ {
 public:
  inline ImageZoomReply() : ImageZoomReply(nullptr) {};
  virtual ~ImageZoomReply();

  ImageZoomReply(const ImageZoomReply& from);
  ImageZoomReply(ImageZoomReply&& from) noexcept
    : ImageZoomReply() {
    *this = ::std::move(from);
  }

  inline ImageZoomReply& operator=(const ImageZoomReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageZoomReply& operator=(ImageZoomReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageZoomReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageZoomReply* internal_default_instance() {
    return reinterpret_cast<const ImageZoomReply*>(
               &_ImageZoomReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ImageZoomReply& a, ImageZoomReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageZoomReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageZoomReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageZoomReply* New() const final {
    return CreateMaybeMessage<ImageZoomReply>(nullptr);
  }

  ImageZoomReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageZoomReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageZoomReply& from);
  void MergeFrom(const ImageZoomReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageZoomReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImageZoomReply";
  }
  protected:
  explicit ImageZoomReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImageZoomReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImagePatchRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImagePatchRequest) */ {
 public:
  inline ImagePatchRequest() : ImagePatchRequest(nullptr) {};
  virtual ~ImagePatchRequest();

  ImagePatchRequest(const ImagePatchRequest& from);
  ImagePatchRequest(ImagePatchRequest&& from) noexcept
    : ImagePatchRequest() {
    *this = ::std::move(from);
  }

  inline ImagePatchRequest& operator=(const ImagePatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagePatchRequest& operator=(ImagePatchRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImagePatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImagePatchRequest* internal_default_instance() {
    return reinterpret_cast<const ImagePatchRequest*>(
               &_ImagePatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImagePatchRequest& a, ImagePatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagePatchRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagePatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImagePatchRequest* New() const final {
    return CreateMaybeMessage<ImagePatchRequest>(nullptr);
  }

  ImagePatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImagePatchRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImagePatchRequest& from);
  void MergeFrom(const ImagePatchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagePatchRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImagePatchRequest";
  }
  protected:
  explicit ImagePatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
    kMidFieldNumber = 3,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string mid = 3;
  void clear_mid();
  const std::string& mid() const;
  void set_mid(const std::string& value);
  void set_mid(std::string&& value);
  void set_mid(const char* value);
  void set_mid(const char* value, size_t size);
  std::string* mutable_mid();
  std::string* release_mid();
  void set_allocated_mid(std::string* mid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_mid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_mid(
      std::string* mid);
  private:
  const std::string& _internal_mid() const;
  void _internal_set_mid(const std::string& value);
  std::string* _internal_mutable_mid();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImagePatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class ImagePatchReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.ImagePatchReply) */ {
 public:
  inline ImagePatchReply() : ImagePatchReply(nullptr) {};
  virtual ~ImagePatchReply();

  ImagePatchReply(const ImagePatchReply& from);
  ImagePatchReply(ImagePatchReply&& from) noexcept
    : ImagePatchReply() {
    *this = ::std::move(from);
  }

  inline ImagePatchReply& operator=(const ImagePatchReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagePatchReply& operator=(ImagePatchReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImagePatchReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImagePatchReply* internal_default_instance() {
    return reinterpret_cast<const ImagePatchReply*>(
               &_ImagePatchReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ImagePatchReply& a, ImagePatchReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagePatchReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagePatchReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImagePatchReply* New() const final {
    return CreateMaybeMessage<ImagePatchReply>(nullptr);
  }

  ImagePatchReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImagePatchReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImagePatchReply& from);
  void MergeFrom(const ImagePatchReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagePatchReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.ImagePatchReply";
  }
  protected:
  explicit ImagePatchReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.ImagePatchReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoCleanRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoCleanRequest) */ {
 public:
  inline VideoCleanRequest() : VideoCleanRequest(nullptr) {};
  virtual ~VideoCleanRequest();

  VideoCleanRequest(const VideoCleanRequest& from);
  VideoCleanRequest(VideoCleanRequest&& from) noexcept
    : VideoCleanRequest() {
    *this = ::std::move(from);
  }

  inline VideoCleanRequest& operator=(const VideoCleanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoCleanRequest& operator=(VideoCleanRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoCleanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoCleanRequest* internal_default_instance() {
    return reinterpret_cast<const VideoCleanRequest*>(
               &_VideoCleanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VideoCleanRequest& a, VideoCleanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoCleanRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoCleanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoCleanRequest* New() const final {
    return CreateMaybeMessage<VideoCleanRequest>(nullptr);
  }

  VideoCleanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoCleanRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoCleanRequest& from);
  void MergeFrom(const VideoCleanRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoCleanRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoCleanRequest";
  }
  protected:
  explicit VideoCleanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoCleanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoCleanReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoCleanReply) */ {
 public:
  inline VideoCleanReply() : VideoCleanReply(nullptr) {};
  virtual ~VideoCleanReply();

  VideoCleanReply(const VideoCleanReply& from);
  VideoCleanReply(VideoCleanReply&& from) noexcept
    : VideoCleanReply() {
    *this = ::std::move(from);
  }

  inline VideoCleanReply& operator=(const VideoCleanReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoCleanReply& operator=(VideoCleanReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoCleanReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoCleanReply* internal_default_instance() {
    return reinterpret_cast<const VideoCleanReply*>(
               &_VideoCleanReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VideoCleanReply& a, VideoCleanReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoCleanReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoCleanReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoCleanReply* New() const final {
    return CreateMaybeMessage<VideoCleanReply>(nullptr);
  }

  VideoCleanReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoCleanReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoCleanReply& from);
  void MergeFrom(const VideoCleanReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoCleanReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoCleanReply";
  }
  protected:
  explicit VideoCleanReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoCleanReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoColorRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoColorRequest) */ {
 public:
  inline VideoColorRequest() : VideoColorRequest(nullptr) {};
  virtual ~VideoColorRequest();

  VideoColorRequest(const VideoColorRequest& from);
  VideoColorRequest(VideoColorRequest&& from) noexcept
    : VideoColorRequest() {
    *this = ::std::move(from);
  }

  inline VideoColorRequest& operator=(const VideoColorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoColorRequest& operator=(VideoColorRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoColorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoColorRequest* internal_default_instance() {
    return reinterpret_cast<const VideoColorRequest*>(
               &_VideoColorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VideoColorRequest& a, VideoColorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoColorRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoColorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoColorRequest* New() const final {
    return CreateMaybeMessage<VideoColorRequest>(nullptr);
  }

  VideoColorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoColorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoColorRequest& from);
  void MergeFrom(const VideoColorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoColorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoColorRequest";
  }
  protected:
  explicit VideoColorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
    kRidFieldNumber = 3,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  void set_rid(const std::string& value);
  void set_rid(std::string&& value);
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  std::string* mutable_rid();
  std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rid(
      std::string* rid);
  private:
  const std::string& _internal_rid() const;
  void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoColorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoColorReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoColorReply) */ {
 public:
  inline VideoColorReply() : VideoColorReply(nullptr) {};
  virtual ~VideoColorReply();

  VideoColorReply(const VideoColorReply& from);
  VideoColorReply(VideoColorReply&& from) noexcept
    : VideoColorReply() {
    *this = ::std::move(from);
  }

  inline VideoColorReply& operator=(const VideoColorReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoColorReply& operator=(VideoColorReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoColorReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoColorReply* internal_default_instance() {
    return reinterpret_cast<const VideoColorReply*>(
               &_VideoColorReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VideoColorReply& a, VideoColorReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoColorReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoColorReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoColorReply* New() const final {
    return CreateMaybeMessage<VideoColorReply>(nullptr);
  }

  VideoColorReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoColorReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoColorReply& from);
  void MergeFrom(const VideoColorReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoColorReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoColorReply";
  }
  protected:
  explicit VideoColorReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoColorReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoZoomRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoZoomRequest) */ {
 public:
  inline VideoZoomRequest() : VideoZoomRequest(nullptr) {};
  virtual ~VideoZoomRequest();

  VideoZoomRequest(const VideoZoomRequest& from);
  VideoZoomRequest(VideoZoomRequest&& from) noexcept
    : VideoZoomRequest() {
    *this = ::std::move(from);
  }

  inline VideoZoomRequest& operator=(const VideoZoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoZoomRequest& operator=(VideoZoomRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoZoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoZoomRequest* internal_default_instance() {
    return reinterpret_cast<const VideoZoomRequest*>(
               &_VideoZoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VideoZoomRequest& a, VideoZoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoZoomRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoZoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoZoomRequest* New() const final {
    return CreateMaybeMessage<VideoZoomRequest>(nullptr);
  }

  VideoZoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoZoomRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoZoomRequest& from);
  void MergeFrom(const VideoZoomRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoZoomRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoZoomRequest";
  }
  protected:
  explicit VideoZoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoZoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoZoomReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoZoomReply) */ {
 public:
  inline VideoZoomReply() : VideoZoomReply(nullptr) {};
  virtual ~VideoZoomReply();

  VideoZoomReply(const VideoZoomReply& from);
  VideoZoomReply(VideoZoomReply&& from) noexcept
    : VideoZoomReply() {
    *this = ::std::move(from);
  }

  inline VideoZoomReply& operator=(const VideoZoomReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoZoomReply& operator=(VideoZoomReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoZoomReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoZoomReply* internal_default_instance() {
    return reinterpret_cast<const VideoZoomReply*>(
               &_VideoZoomReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(VideoZoomReply& a, VideoZoomReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoZoomReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoZoomReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoZoomReply* New() const final {
    return CreateMaybeMessage<VideoZoomReply>(nullptr);
  }

  VideoZoomReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoZoomReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoZoomReply& from);
  void MergeFrom(const VideoZoomReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoZoomReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoZoomReply";
  }
  protected:
  explicit VideoZoomReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoZoomReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoSlowRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoSlowRequest) */ {
 public:
  inline VideoSlowRequest() : VideoSlowRequest(nullptr) {};
  virtual ~VideoSlowRequest();

  VideoSlowRequest(const VideoSlowRequest& from);
  VideoSlowRequest(VideoSlowRequest&& from) noexcept
    : VideoSlowRequest() {
    *this = ::std::move(from);
  }

  inline VideoSlowRequest& operator=(const VideoSlowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSlowRequest& operator=(VideoSlowRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoSlowRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoSlowRequest* internal_default_instance() {
    return reinterpret_cast<const VideoSlowRequest*>(
               &_VideoSlowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VideoSlowRequest& a, VideoSlowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSlowRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSlowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoSlowRequest* New() const final {
    return CreateMaybeMessage<VideoSlowRequest>(nullptr);
  }

  VideoSlowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoSlowRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoSlowRequest& from);
  void MergeFrom(const VideoSlowRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoSlowRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoSlowRequest";
  }
  protected:
  explicit VideoSlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string method = 1;
  void clear_method();
  const std::string& method() const;
  void set_method(const std::string& value);
  void set_method(std::string&& value);
  void set_method(const char* value);
  void set_method(const char* value, size_t size);
  std::string* mutable_method();
  std::string* release_method();
  void set_allocated_method(std::string* method);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_method();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_method(
      std::string* method);
  private:
  const std::string& _internal_method() const;
  void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoSlowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// -------------------------------------------------------------------

class VideoSlowReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensor.VideoSlowReply) */ {
 public:
  inline VideoSlowReply() : VideoSlowReply(nullptr) {};
  virtual ~VideoSlowReply();

  VideoSlowReply(const VideoSlowReply& from);
  VideoSlowReply(VideoSlowReply&& from) noexcept
    : VideoSlowReply() {
    *this = ::std::move(from);
  }

  inline VideoSlowReply& operator=(const VideoSlowReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSlowReply& operator=(VideoSlowReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoSlowReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoSlowReply* internal_default_instance() {
    return reinterpret_cast<const VideoSlowReply*>(
               &_VideoSlowReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(VideoSlowReply& a, VideoSlowReply& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSlowReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSlowReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoSlowReply* New() const final {
    return CreateMaybeMessage<VideoSlowReply>(nullptr);
  }

  VideoSlowReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoSlowReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoSlowReply& from);
  void MergeFrom(const VideoSlowReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoSlowReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensor.VideoSlowReply";
  }
  protected:
  explicit VideoSlowReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tensor_2eproto);
    return ::descriptor_table_tensor_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string oid = 1;
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_oid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_oid(
      std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tensor.VideoSlowReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tensor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:tensor.HelloRequest.name)
  return _internal_name();
}
inline void HelloRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:tensor.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:tensor.HelloRequest.name)
  return _internal_mutable_name();
}
inline const std::string& HelloRequest::_internal_name() const {
  return name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HelloRequest::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.HelloRequest.name)
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:tensor.HelloRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.HelloRequest.name)
}
inline std::string* HelloRequest::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.HelloRequest.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HelloRequest::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.HelloReply.message)
  return _internal_message();
}
inline void HelloReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.HelloReply.message)
  return _internal_mutable_message();
}
inline const std::string& HelloReply::_internal_message() const {
  return message_.Get();
}
inline void HelloReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HelloReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.HelloReply.message)
}
inline void HelloReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.HelloReply.message)
}
inline void HelloReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.HelloReply.message)
}
inline std::string* HelloReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.HelloReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.HelloReply.message)
}
inline std::string* HelloReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.HelloReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HelloReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.HelloReply.message)
}

// -------------------------------------------------------------------

// Tensor

// int32 N = 1;
inline void Tensor::clear_n() {
  n_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::_internal_n() const {
  return n_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::n() const {
  // @@protoc_insertion_point(field_get:tensor.Tensor.N)
  return _internal_n();
}
inline void Tensor::_internal_set_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  n_ = value;
}
inline void Tensor::set_n(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:tensor.Tensor.N)
}

// int32 C = 2;
inline void Tensor::clear_c() {
  c_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::_internal_c() const {
  return c_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::c() const {
  // @@protoc_insertion_point(field_get:tensor.Tensor.C)
  return _internal_c();
}
inline void Tensor::_internal_set_c(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  c_ = value;
}
inline void Tensor::set_c(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_c(value);
  // @@protoc_insertion_point(field_set:tensor.Tensor.C)
}

// int32 H = 3;
inline void Tensor::clear_h() {
  h_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::_internal_h() const {
  return h_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::h() const {
  // @@protoc_insertion_point(field_get:tensor.Tensor.H)
  return _internal_h();
}
inline void Tensor::_internal_set_h(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  h_ = value;
}
inline void Tensor::set_h(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:tensor.Tensor.H)
}

// int32 W = 4;
inline void Tensor::clear_w() {
  w_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::_internal_w() const {
  return w_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Tensor::w() const {
  // @@protoc_insertion_point(field_get:tensor.Tensor.W)
  return _internal_w();
}
inline void Tensor::_internal_set_w(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  w_ = value;
}
inline void Tensor::set_w(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:tensor.Tensor.W)
}

// bytes data = 5;
inline void Tensor::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Tensor::data() const {
  // @@protoc_insertion_point(field_get:tensor.Tensor.data)
  return _internal_data();
}
inline void Tensor::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:tensor.Tensor.data)
}
inline std::string* Tensor::mutable_data() {
  // @@protoc_insertion_point(field_mutable:tensor.Tensor.data)
  return _internal_mutable_data();
}
inline const std::string& Tensor::_internal_data() const {
  return data_.Get();
}
inline void Tensor::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Tensor::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.Tensor.data)
}
inline void Tensor::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.Tensor.data)
}
inline void Tensor::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.Tensor.data)
}
inline std::string* Tensor::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Tensor::release_data() {
  // @@protoc_insertion_point(field_release:tensor.Tensor.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Tensor::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.Tensor.data)
}
inline std::string* Tensor::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.Tensor.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Tensor::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    
  } else {
    
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.Tensor.data)
}

// -------------------------------------------------------------------

// SetTensorRequest

// string id = 1;
inline void SetTensorRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetTensorRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.SetTensorRequest.id)
  return _internal_id();
}
inline void SetTensorRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.SetTensorRequest.id)
}
inline std::string* SetTensorRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.SetTensorRequest.id)
  return _internal_mutable_id();
}
inline const std::string& SetTensorRequest::_internal_id() const {
  return id_.Get();
}
inline void SetTensorRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetTensorRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.SetTensorRequest.id)
}
inline void SetTensorRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.SetTensorRequest.id)
}
inline void SetTensorRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.SetTensorRequest.id)
}
inline std::string* SetTensorRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetTensorRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.SetTensorRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetTensorRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.SetTensorRequest.id)
}
inline std::string* SetTensorRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.SetTensorRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetTensorRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.SetTensorRequest.id)
}

// .tensor.Tensor tensor = 2;
inline bool SetTensorRequest::_internal_has_tensor() const {
  return this != internal_default_instance() && tensor_ != nullptr;
}
inline bool SetTensorRequest::has_tensor() const {
  return _internal_has_tensor();
}
inline void SetTensorRequest::clear_tensor() {
  if (GetArena() == nullptr && tensor_ != nullptr) {
    delete tensor_;
  }
  tensor_ = nullptr;
}
inline const ::tensor::Tensor& SetTensorRequest::_internal_tensor() const {
  const ::tensor::Tensor* p = tensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tensor::Tensor*>(
      &::tensor::_Tensor_default_instance_);
}
inline const ::tensor::Tensor& SetTensorRequest::tensor() const {
  // @@protoc_insertion_point(field_get:tensor.SetTensorRequest.tensor)
  return _internal_tensor();
}
inline void SetTensorRequest::unsafe_arena_set_allocated_tensor(
    ::tensor::Tensor* tensor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor_);
  }
  tensor_ = tensor;
  if (tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.SetTensorRequest.tensor)
}
inline ::tensor::Tensor* SetTensorRequest::release_tensor() {
  auto temp = unsafe_arena_release_tensor();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tensor::Tensor* SetTensorRequest::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_release:tensor.SetTensorRequest.tensor)
  
  ::tensor::Tensor* temp = tensor_;
  tensor_ = nullptr;
  return temp;
}
inline ::tensor::Tensor* SetTensorRequest::_internal_mutable_tensor() {
  
  if (tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensor::Tensor>(GetArena());
    tensor_ = p;
  }
  return tensor_;
}
inline ::tensor::Tensor* SetTensorRequest::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable:tensor.SetTensorRequest.tensor)
  return _internal_mutable_tensor();
}
inline void SetTensorRequest::set_allocated_tensor(::tensor::Tensor* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    
  } else {
    
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:tensor.SetTensorRequest.tensor)
}

// -------------------------------------------------------------------

// SetTensorReply

// string message = 1;
inline void SetTensorReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetTensorReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.SetTensorReply.message)
  return _internal_message();
}
inline void SetTensorReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.SetTensorReply.message)
}
inline std::string* SetTensorReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.SetTensorReply.message)
  return _internal_mutable_message();
}
inline const std::string& SetTensorReply::_internal_message() const {
  return message_.Get();
}
inline void SetTensorReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetTensorReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.SetTensorReply.message)
}
inline void SetTensorReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.SetTensorReply.message)
}
inline void SetTensorReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.SetTensorReply.message)
}
inline std::string* SetTensorReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetTensorReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.SetTensorReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetTensorReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.SetTensorReply.message)
}
inline std::string* SetTensorReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.SetTensorReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SetTensorReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.SetTensorReply.message)
}

// -------------------------------------------------------------------

// GetTensorRequest

// string id = 1;
inline void GetTensorRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetTensorRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.GetTensorRequest.id)
  return _internal_id();
}
inline void GetTensorRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.GetTensorRequest.id)
}
inline std::string* GetTensorRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.GetTensorRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GetTensorRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTensorRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetTensorRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.GetTensorRequest.id)
}
inline void GetTensorRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.GetTensorRequest.id)
}
inline void GetTensorRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.GetTensorRequest.id)
}
inline std::string* GetTensorRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetTensorRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.GetTensorRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetTensorRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.GetTensorRequest.id)
}
inline std::string* GetTensorRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.GetTensorRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetTensorRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.GetTensorRequest.id)
}

// -------------------------------------------------------------------

// GetTensorReply

// .tensor.Tensor tensor = 1;
inline bool GetTensorReply::_internal_has_tensor() const {
  return this != internal_default_instance() && tensor_ != nullptr;
}
inline bool GetTensorReply::has_tensor() const {
  return _internal_has_tensor();
}
inline void GetTensorReply::clear_tensor() {
  if (GetArena() == nullptr && tensor_ != nullptr) {
    delete tensor_;
  }
  tensor_ = nullptr;
}
inline const ::tensor::Tensor& GetTensorReply::_internal_tensor() const {
  const ::tensor::Tensor* p = tensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::tensor::Tensor*>(
      &::tensor::_Tensor_default_instance_);
}
inline const ::tensor::Tensor& GetTensorReply::tensor() const {
  // @@protoc_insertion_point(field_get:tensor.GetTensorReply.tensor)
  return _internal_tensor();
}
inline void GetTensorReply::unsafe_arena_set_allocated_tensor(
    ::tensor::Tensor* tensor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor_);
  }
  tensor_ = tensor;
  if (tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.GetTensorReply.tensor)
}
inline ::tensor::Tensor* GetTensorReply::release_tensor() {
  auto temp = unsafe_arena_release_tensor();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tensor::Tensor* GetTensorReply::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_release:tensor.GetTensorReply.tensor)
  
  ::tensor::Tensor* temp = tensor_;
  tensor_ = nullptr;
  return temp;
}
inline ::tensor::Tensor* GetTensorReply::_internal_mutable_tensor() {
  
  if (tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensor::Tensor>(GetArena());
    tensor_ = p;
  }
  return tensor_;
}
inline ::tensor::Tensor* GetTensorReply::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable:tensor.GetTensorReply.tensor)
  return _internal_mutable_tensor();
}
inline void GetTensorReply::set_allocated_tensor(::tensor::Tensor* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    
  } else {
    
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:tensor.GetTensorReply.tensor)
}

// -------------------------------------------------------------------

// DelTensorRequest

// string id = 1;
inline void DelTensorRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DelTensorRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.DelTensorRequest.id)
  return _internal_id();
}
inline void DelTensorRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.DelTensorRequest.id)
}
inline std::string* DelTensorRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.DelTensorRequest.id)
  return _internal_mutable_id();
}
inline const std::string& DelTensorRequest::_internal_id() const {
  return id_.Get();
}
inline void DelTensorRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DelTensorRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.DelTensorRequest.id)
}
inline void DelTensorRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.DelTensorRequest.id)
}
inline void DelTensorRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.DelTensorRequest.id)
}
inline std::string* DelTensorRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DelTensorRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.DelTensorRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DelTensorRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.DelTensorRequest.id)
}
inline std::string* DelTensorRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.DelTensorRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DelTensorRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.DelTensorRequest.id)
}

// -------------------------------------------------------------------

// DelTensorReply

// string message = 1;
inline void DelTensorReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DelTensorReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.DelTensorReply.message)
  return _internal_message();
}
inline void DelTensorReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.DelTensorReply.message)
}
inline std::string* DelTensorReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.DelTensorReply.message)
  return _internal_mutable_message();
}
inline const std::string& DelTensorReply::_internal_message() const {
  return message_.Get();
}
inline void DelTensorReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DelTensorReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.DelTensorReply.message)
}
inline void DelTensorReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.DelTensorReply.message)
}
inline void DelTensorReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.DelTensorReply.message)
}
inline std::string* DelTensorReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DelTensorReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.DelTensorReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DelTensorReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.DelTensorReply.message)
}
inline std::string* DelTensorReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.DelTensorReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DelTensorReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.DelTensorReply.message)
}

// -------------------------------------------------------------------

// ImageCleanRequest

// string method = 1;
inline void ImageCleanRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageCleanRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.ImageCleanRequest.method)
  return _internal_method();
}
inline void ImageCleanRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.ImageCleanRequest.method)
}
inline std::string* ImageCleanRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageCleanRequest.method)
  return _internal_mutable_method();
}
inline const std::string& ImageCleanRequest::_internal_method() const {
  return method_.Get();
}
inline void ImageCleanRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCleanRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageCleanRequest.method)
}
inline void ImageCleanRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageCleanRequest.method)
}
inline void ImageCleanRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageCleanRequest.method)
}
inline std::string* ImageCleanRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCleanRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.ImageCleanRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCleanRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageCleanRequest.method)
}
inline std::string* ImageCleanRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageCleanRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageCleanRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageCleanRequest.method)
}

// string id = 2;
inline void ImageCleanRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageCleanRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.ImageCleanRequest.id)
  return _internal_id();
}
inline void ImageCleanRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.ImageCleanRequest.id)
}
inline std::string* ImageCleanRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageCleanRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ImageCleanRequest::_internal_id() const {
  return id_.Get();
}
inline void ImageCleanRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCleanRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageCleanRequest.id)
}
inline void ImageCleanRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageCleanRequest.id)
}
inline void ImageCleanRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageCleanRequest.id)
}
inline std::string* ImageCleanRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCleanRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.ImageCleanRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCleanRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageCleanRequest.id)
}
inline std::string* ImageCleanRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageCleanRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageCleanRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageCleanRequest.id)
}

// -------------------------------------------------------------------

// ImageCleanReply

// string oid = 1;
inline void ImageCleanReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageCleanReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.ImageCleanReply.oid)
  return _internal_oid();
}
inline void ImageCleanReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.ImageCleanReply.oid)
}
inline std::string* ImageCleanReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageCleanReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& ImageCleanReply::_internal_oid() const {
  return oid_.Get();
}
inline void ImageCleanReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCleanReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageCleanReply.oid)
}
inline void ImageCleanReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageCleanReply.oid)
}
inline void ImageCleanReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageCleanReply.oid)
}
inline std::string* ImageCleanReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCleanReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.ImageCleanReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCleanReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageCleanReply.oid)
}
inline std::string* ImageCleanReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageCleanReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageCleanReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageCleanReply.oid)
}

// string message = 2;
inline void ImageCleanReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageCleanReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.ImageCleanReply.message)
  return _internal_message();
}
inline void ImageCleanReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.ImageCleanReply.message)
}
inline std::string* ImageCleanReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageCleanReply.message)
  return _internal_mutable_message();
}
inline const std::string& ImageCleanReply::_internal_message() const {
  return message_.Get();
}
inline void ImageCleanReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCleanReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageCleanReply.message)
}
inline void ImageCleanReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageCleanReply.message)
}
inline void ImageCleanReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageCleanReply.message)
}
inline std::string* ImageCleanReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCleanReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.ImageCleanReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCleanReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageCleanReply.message)
}
inline std::string* ImageCleanReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageCleanReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageCleanReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageCleanReply.message)
}

// -------------------------------------------------------------------

// ImageColorRequest

// string method = 1;
inline void ImageColorRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageColorRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.ImageColorRequest.method)
  return _internal_method();
}
inline void ImageColorRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.ImageColorRequest.method)
}
inline std::string* ImageColorRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageColorRequest.method)
  return _internal_mutable_method();
}
inline const std::string& ImageColorRequest::_internal_method() const {
  return method_.Get();
}
inline void ImageColorRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageColorRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageColorRequest.method)
}
inline void ImageColorRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageColorRequest.method)
}
inline void ImageColorRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageColorRequest.method)
}
inline std::string* ImageColorRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageColorRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.ImageColorRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageColorRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageColorRequest.method)
}
inline std::string* ImageColorRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageColorRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageColorRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageColorRequest.method)
}

// string id = 2;
inline void ImageColorRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageColorRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.ImageColorRequest.id)
  return _internal_id();
}
inline void ImageColorRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.ImageColorRequest.id)
}
inline std::string* ImageColorRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageColorRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ImageColorRequest::_internal_id() const {
  return id_.Get();
}
inline void ImageColorRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageColorRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageColorRequest.id)
}
inline void ImageColorRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageColorRequest.id)
}
inline void ImageColorRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageColorRequest.id)
}
inline std::string* ImageColorRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageColorRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.ImageColorRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageColorRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageColorRequest.id)
}
inline std::string* ImageColorRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageColorRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageColorRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageColorRequest.id)
}

// string rid = 3;
inline void ImageColorRequest::clear_rid() {
  rid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageColorRequest::rid() const {
  // @@protoc_insertion_point(field_get:tensor.ImageColorRequest.rid)
  return _internal_rid();
}
inline void ImageColorRequest::set_rid(const std::string& value) {
  _internal_set_rid(value);
  // @@protoc_insertion_point(field_set:tensor.ImageColorRequest.rid)
}
inline std::string* ImageColorRequest::mutable_rid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageColorRequest.rid)
  return _internal_mutable_rid();
}
inline const std::string& ImageColorRequest::_internal_rid() const {
  return rid_.Get();
}
inline void ImageColorRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageColorRequest::set_rid(std::string&& value) {
  
  rid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageColorRequest.rid)
}
inline void ImageColorRequest::set_rid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageColorRequest.rid)
}
inline void ImageColorRequest::set_rid(const char* value,
    size_t size) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageColorRequest.rid)
}
inline std::string* ImageColorRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageColorRequest::release_rid() {
  // @@protoc_insertion_point(field_release:tensor.ImageColorRequest.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageColorRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageColorRequest.rid)
}
inline std::string* ImageColorRequest::unsafe_arena_release_rid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageColorRequest.rid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return rid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageColorRequest::unsafe_arena_set_allocated_rid(
    std::string* rid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageColorRequest.rid)
}

// -------------------------------------------------------------------

// ImageColorReply

// string oid = 1;
inline void ImageColorReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageColorReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.ImageColorReply.oid)
  return _internal_oid();
}
inline void ImageColorReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.ImageColorReply.oid)
}
inline std::string* ImageColorReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageColorReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& ImageColorReply::_internal_oid() const {
  return oid_.Get();
}
inline void ImageColorReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageColorReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageColorReply.oid)
}
inline void ImageColorReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageColorReply.oid)
}
inline void ImageColorReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageColorReply.oid)
}
inline std::string* ImageColorReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageColorReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.ImageColorReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageColorReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageColorReply.oid)
}
inline std::string* ImageColorReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageColorReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageColorReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageColorReply.oid)
}

// string message = 2;
inline void ImageColorReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageColorReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.ImageColorReply.message)
  return _internal_message();
}
inline void ImageColorReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.ImageColorReply.message)
}
inline std::string* ImageColorReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageColorReply.message)
  return _internal_mutable_message();
}
inline const std::string& ImageColorReply::_internal_message() const {
  return message_.Get();
}
inline void ImageColorReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageColorReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageColorReply.message)
}
inline void ImageColorReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageColorReply.message)
}
inline void ImageColorReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageColorReply.message)
}
inline std::string* ImageColorReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageColorReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.ImageColorReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageColorReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageColorReply.message)
}
inline std::string* ImageColorReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageColorReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageColorReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageColorReply.message)
}

// -------------------------------------------------------------------

// ImageZoomRequest

// string method = 1;
inline void ImageZoomRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageZoomRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.ImageZoomRequest.method)
  return _internal_method();
}
inline void ImageZoomRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.ImageZoomRequest.method)
}
inline std::string* ImageZoomRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageZoomRequest.method)
  return _internal_mutable_method();
}
inline const std::string& ImageZoomRequest::_internal_method() const {
  return method_.Get();
}
inline void ImageZoomRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageZoomRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageZoomRequest.method)
}
inline void ImageZoomRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageZoomRequest.method)
}
inline void ImageZoomRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageZoomRequest.method)
}
inline std::string* ImageZoomRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageZoomRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.ImageZoomRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageZoomRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageZoomRequest.method)
}
inline std::string* ImageZoomRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageZoomRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageZoomRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageZoomRequest.method)
}

// string id = 2;
inline void ImageZoomRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageZoomRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.ImageZoomRequest.id)
  return _internal_id();
}
inline void ImageZoomRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.ImageZoomRequest.id)
}
inline std::string* ImageZoomRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageZoomRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ImageZoomRequest::_internal_id() const {
  return id_.Get();
}
inline void ImageZoomRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageZoomRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageZoomRequest.id)
}
inline void ImageZoomRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageZoomRequest.id)
}
inline void ImageZoomRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageZoomRequest.id)
}
inline std::string* ImageZoomRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageZoomRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.ImageZoomRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageZoomRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageZoomRequest.id)
}
inline std::string* ImageZoomRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageZoomRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageZoomRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageZoomRequest.id)
}

// -------------------------------------------------------------------

// ImageZoomReply

// string oid = 1;
inline void ImageZoomReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageZoomReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.ImageZoomReply.oid)
  return _internal_oid();
}
inline void ImageZoomReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.ImageZoomReply.oid)
}
inline std::string* ImageZoomReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageZoomReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& ImageZoomReply::_internal_oid() const {
  return oid_.Get();
}
inline void ImageZoomReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageZoomReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageZoomReply.oid)
}
inline void ImageZoomReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageZoomReply.oid)
}
inline void ImageZoomReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageZoomReply.oid)
}
inline std::string* ImageZoomReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageZoomReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.ImageZoomReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageZoomReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageZoomReply.oid)
}
inline std::string* ImageZoomReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageZoomReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageZoomReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageZoomReply.oid)
}

// string message = 2;
inline void ImageZoomReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageZoomReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.ImageZoomReply.message)
  return _internal_message();
}
inline void ImageZoomReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.ImageZoomReply.message)
}
inline std::string* ImageZoomReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.ImageZoomReply.message)
  return _internal_mutable_message();
}
inline const std::string& ImageZoomReply::_internal_message() const {
  return message_.Get();
}
inline void ImageZoomReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageZoomReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImageZoomReply.message)
}
inline void ImageZoomReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImageZoomReply.message)
}
inline void ImageZoomReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImageZoomReply.message)
}
inline std::string* ImageZoomReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageZoomReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.ImageZoomReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageZoomReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImageZoomReply.message)
}
inline std::string* ImageZoomReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImageZoomReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImageZoomReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImageZoomReply.message)
}

// -------------------------------------------------------------------

// ImagePatchRequest

// string method = 1;
inline void ImagePatchRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImagePatchRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.ImagePatchRequest.method)
  return _internal_method();
}
inline void ImagePatchRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.ImagePatchRequest.method)
}
inline std::string* ImagePatchRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.ImagePatchRequest.method)
  return _internal_mutable_method();
}
inline const std::string& ImagePatchRequest::_internal_method() const {
  return method_.Get();
}
inline void ImagePatchRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImagePatchRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImagePatchRequest.method)
}
inline void ImagePatchRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImagePatchRequest.method)
}
inline void ImagePatchRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImagePatchRequest.method)
}
inline std::string* ImagePatchRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImagePatchRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.ImagePatchRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImagePatchRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImagePatchRequest.method)
}
inline std::string* ImagePatchRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImagePatchRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImagePatchRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImagePatchRequest.method)
}

// string id = 2;
inline void ImagePatchRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImagePatchRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.ImagePatchRequest.id)
  return _internal_id();
}
inline void ImagePatchRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.ImagePatchRequest.id)
}
inline std::string* ImagePatchRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.ImagePatchRequest.id)
  return _internal_mutable_id();
}
inline const std::string& ImagePatchRequest::_internal_id() const {
  return id_.Get();
}
inline void ImagePatchRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImagePatchRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImagePatchRequest.id)
}
inline void ImagePatchRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImagePatchRequest.id)
}
inline void ImagePatchRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImagePatchRequest.id)
}
inline std::string* ImagePatchRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImagePatchRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.ImagePatchRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImagePatchRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImagePatchRequest.id)
}
inline std::string* ImagePatchRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImagePatchRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImagePatchRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImagePatchRequest.id)
}

// string mid = 3;
inline void ImagePatchRequest::clear_mid() {
  mid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImagePatchRequest::mid() const {
  // @@protoc_insertion_point(field_get:tensor.ImagePatchRequest.mid)
  return _internal_mid();
}
inline void ImagePatchRequest::set_mid(const std::string& value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:tensor.ImagePatchRequest.mid)
}
inline std::string* ImagePatchRequest::mutable_mid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImagePatchRequest.mid)
  return _internal_mutable_mid();
}
inline const std::string& ImagePatchRequest::_internal_mid() const {
  return mid_.Get();
}
inline void ImagePatchRequest::_internal_set_mid(const std::string& value) {
  
  mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImagePatchRequest::set_mid(std::string&& value) {
  
  mid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImagePatchRequest.mid)
}
inline void ImagePatchRequest::set_mid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImagePatchRequest.mid)
}
inline void ImagePatchRequest::set_mid(const char* value,
    size_t size) {
  
  mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImagePatchRequest.mid)
}
inline std::string* ImagePatchRequest::_internal_mutable_mid() {
  
  return mid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImagePatchRequest::release_mid() {
  // @@protoc_insertion_point(field_release:tensor.ImagePatchRequest.mid)
  return mid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImagePatchRequest::set_allocated_mid(std::string* mid) {
  if (mid != nullptr) {
    
  } else {
    
  }
  mid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImagePatchRequest.mid)
}
inline std::string* ImagePatchRequest::unsafe_arena_release_mid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImagePatchRequest.mid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return mid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImagePatchRequest::unsafe_arena_set_allocated_mid(
    std::string* mid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (mid != nullptr) {
    
  } else {
    
  }
  mid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      mid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImagePatchRequest.mid)
}

// -------------------------------------------------------------------

// ImagePatchReply

// string oid = 1;
inline void ImagePatchReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImagePatchReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.ImagePatchReply.oid)
  return _internal_oid();
}
inline void ImagePatchReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.ImagePatchReply.oid)
}
inline std::string* ImagePatchReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.ImagePatchReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& ImagePatchReply::_internal_oid() const {
  return oid_.Get();
}
inline void ImagePatchReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImagePatchReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImagePatchReply.oid)
}
inline void ImagePatchReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImagePatchReply.oid)
}
inline void ImagePatchReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImagePatchReply.oid)
}
inline std::string* ImagePatchReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImagePatchReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.ImagePatchReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImagePatchReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImagePatchReply.oid)
}
inline std::string* ImagePatchReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImagePatchReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImagePatchReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImagePatchReply.oid)
}

// string message = 2;
inline void ImagePatchReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImagePatchReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.ImagePatchReply.message)
  return _internal_message();
}
inline void ImagePatchReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.ImagePatchReply.message)
}
inline std::string* ImagePatchReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.ImagePatchReply.message)
  return _internal_mutable_message();
}
inline const std::string& ImagePatchReply::_internal_message() const {
  return message_.Get();
}
inline void ImagePatchReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImagePatchReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.ImagePatchReply.message)
}
inline void ImagePatchReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.ImagePatchReply.message)
}
inline void ImagePatchReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.ImagePatchReply.message)
}
inline std::string* ImagePatchReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImagePatchReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.ImagePatchReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImagePatchReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.ImagePatchReply.message)
}
inline std::string* ImagePatchReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.ImagePatchReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ImagePatchReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.ImagePatchReply.message)
}

// -------------------------------------------------------------------

// VideoCleanRequest

// string method = 1;
inline void VideoCleanRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoCleanRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.VideoCleanRequest.method)
  return _internal_method();
}
inline void VideoCleanRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.VideoCleanRequest.method)
}
inline std::string* VideoCleanRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoCleanRequest.method)
  return _internal_mutable_method();
}
inline const std::string& VideoCleanRequest::_internal_method() const {
  return method_.Get();
}
inline void VideoCleanRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCleanRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoCleanRequest.method)
}
inline void VideoCleanRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoCleanRequest.method)
}
inline void VideoCleanRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoCleanRequest.method)
}
inline std::string* VideoCleanRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCleanRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.VideoCleanRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCleanRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoCleanRequest.method)
}
inline std::string* VideoCleanRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoCleanRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoCleanRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoCleanRequest.method)
}

// string id = 2;
inline void VideoCleanRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoCleanRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.VideoCleanRequest.id)
  return _internal_id();
}
inline void VideoCleanRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.VideoCleanRequest.id)
}
inline std::string* VideoCleanRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoCleanRequest.id)
  return _internal_mutable_id();
}
inline const std::string& VideoCleanRequest::_internal_id() const {
  return id_.Get();
}
inline void VideoCleanRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCleanRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoCleanRequest.id)
}
inline void VideoCleanRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoCleanRequest.id)
}
inline void VideoCleanRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoCleanRequest.id)
}
inline std::string* VideoCleanRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCleanRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.VideoCleanRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCleanRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoCleanRequest.id)
}
inline std::string* VideoCleanRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoCleanRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoCleanRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoCleanRequest.id)
}

// -------------------------------------------------------------------

// VideoCleanReply

// string oid = 1;
inline void VideoCleanReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoCleanReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.VideoCleanReply.oid)
  return _internal_oid();
}
inline void VideoCleanReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.VideoCleanReply.oid)
}
inline std::string* VideoCleanReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoCleanReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& VideoCleanReply::_internal_oid() const {
  return oid_.Get();
}
inline void VideoCleanReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCleanReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoCleanReply.oid)
}
inline void VideoCleanReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoCleanReply.oid)
}
inline void VideoCleanReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoCleanReply.oid)
}
inline std::string* VideoCleanReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCleanReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.VideoCleanReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCleanReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoCleanReply.oid)
}
inline std::string* VideoCleanReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoCleanReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoCleanReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoCleanReply.oid)
}

// string message = 2;
inline void VideoCleanReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoCleanReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.VideoCleanReply.message)
  return _internal_message();
}
inline void VideoCleanReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.VideoCleanReply.message)
}
inline std::string* VideoCleanReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoCleanReply.message)
  return _internal_mutable_message();
}
inline const std::string& VideoCleanReply::_internal_message() const {
  return message_.Get();
}
inline void VideoCleanReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoCleanReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoCleanReply.message)
}
inline void VideoCleanReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoCleanReply.message)
}
inline void VideoCleanReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoCleanReply.message)
}
inline std::string* VideoCleanReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoCleanReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.VideoCleanReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoCleanReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoCleanReply.message)
}
inline std::string* VideoCleanReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoCleanReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoCleanReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoCleanReply.message)
}

// -------------------------------------------------------------------

// VideoColorRequest

// string method = 1;
inline void VideoColorRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoColorRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.VideoColorRequest.method)
  return _internal_method();
}
inline void VideoColorRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.VideoColorRequest.method)
}
inline std::string* VideoColorRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoColorRequest.method)
  return _internal_mutable_method();
}
inline const std::string& VideoColorRequest::_internal_method() const {
  return method_.Get();
}
inline void VideoColorRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoColorRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoColorRequest.method)
}
inline void VideoColorRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoColorRequest.method)
}
inline void VideoColorRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoColorRequest.method)
}
inline std::string* VideoColorRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoColorRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.VideoColorRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoColorRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoColorRequest.method)
}
inline std::string* VideoColorRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoColorRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoColorRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoColorRequest.method)
}

// string id = 2;
inline void VideoColorRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoColorRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.VideoColorRequest.id)
  return _internal_id();
}
inline void VideoColorRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.VideoColorRequest.id)
}
inline std::string* VideoColorRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoColorRequest.id)
  return _internal_mutable_id();
}
inline const std::string& VideoColorRequest::_internal_id() const {
  return id_.Get();
}
inline void VideoColorRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoColorRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoColorRequest.id)
}
inline void VideoColorRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoColorRequest.id)
}
inline void VideoColorRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoColorRequest.id)
}
inline std::string* VideoColorRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoColorRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.VideoColorRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoColorRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoColorRequest.id)
}
inline std::string* VideoColorRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoColorRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoColorRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoColorRequest.id)
}

// string rid = 3;
inline void VideoColorRequest::clear_rid() {
  rid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoColorRequest::rid() const {
  // @@protoc_insertion_point(field_get:tensor.VideoColorRequest.rid)
  return _internal_rid();
}
inline void VideoColorRequest::set_rid(const std::string& value) {
  _internal_set_rid(value);
  // @@protoc_insertion_point(field_set:tensor.VideoColorRequest.rid)
}
inline std::string* VideoColorRequest::mutable_rid() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoColorRequest.rid)
  return _internal_mutable_rid();
}
inline const std::string& VideoColorRequest::_internal_rid() const {
  return rid_.Get();
}
inline void VideoColorRequest::_internal_set_rid(const std::string& value) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoColorRequest::set_rid(std::string&& value) {
  
  rid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoColorRequest.rid)
}
inline void VideoColorRequest::set_rid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoColorRequest.rid)
}
inline void VideoColorRequest::set_rid(const char* value,
    size_t size) {
  
  rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoColorRequest.rid)
}
inline std::string* VideoColorRequest::_internal_mutable_rid() {
  
  return rid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoColorRequest::release_rid() {
  // @@protoc_insertion_point(field_release:tensor.VideoColorRequest.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoColorRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoColorRequest.rid)
}
inline std::string* VideoColorRequest::unsafe_arena_release_rid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoColorRequest.rid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return rid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoColorRequest::unsafe_arena_set_allocated_rid(
    std::string* rid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoColorRequest.rid)
}

// -------------------------------------------------------------------

// VideoColorReply

// string oid = 1;
inline void VideoColorReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoColorReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.VideoColorReply.oid)
  return _internal_oid();
}
inline void VideoColorReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.VideoColorReply.oid)
}
inline std::string* VideoColorReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoColorReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& VideoColorReply::_internal_oid() const {
  return oid_.Get();
}
inline void VideoColorReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoColorReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoColorReply.oid)
}
inline void VideoColorReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoColorReply.oid)
}
inline void VideoColorReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoColorReply.oid)
}
inline std::string* VideoColorReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoColorReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.VideoColorReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoColorReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoColorReply.oid)
}
inline std::string* VideoColorReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoColorReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoColorReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoColorReply.oid)
}

// string message = 2;
inline void VideoColorReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoColorReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.VideoColorReply.message)
  return _internal_message();
}
inline void VideoColorReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.VideoColorReply.message)
}
inline std::string* VideoColorReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoColorReply.message)
  return _internal_mutable_message();
}
inline const std::string& VideoColorReply::_internal_message() const {
  return message_.Get();
}
inline void VideoColorReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoColorReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoColorReply.message)
}
inline void VideoColorReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoColorReply.message)
}
inline void VideoColorReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoColorReply.message)
}
inline std::string* VideoColorReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoColorReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.VideoColorReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoColorReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoColorReply.message)
}
inline std::string* VideoColorReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoColorReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoColorReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoColorReply.message)
}

// -------------------------------------------------------------------

// VideoZoomRequest

// string method = 1;
inline void VideoZoomRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoZoomRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.VideoZoomRequest.method)
  return _internal_method();
}
inline void VideoZoomRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.VideoZoomRequest.method)
}
inline std::string* VideoZoomRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoZoomRequest.method)
  return _internal_mutable_method();
}
inline const std::string& VideoZoomRequest::_internal_method() const {
  return method_.Get();
}
inline void VideoZoomRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoZoomRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoZoomRequest.method)
}
inline void VideoZoomRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoZoomRequest.method)
}
inline void VideoZoomRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoZoomRequest.method)
}
inline std::string* VideoZoomRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoZoomRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.VideoZoomRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoZoomRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoZoomRequest.method)
}
inline std::string* VideoZoomRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoZoomRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoZoomRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoZoomRequest.method)
}

// string id = 2;
inline void VideoZoomRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoZoomRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.VideoZoomRequest.id)
  return _internal_id();
}
inline void VideoZoomRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.VideoZoomRequest.id)
}
inline std::string* VideoZoomRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoZoomRequest.id)
  return _internal_mutable_id();
}
inline const std::string& VideoZoomRequest::_internal_id() const {
  return id_.Get();
}
inline void VideoZoomRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoZoomRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoZoomRequest.id)
}
inline void VideoZoomRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoZoomRequest.id)
}
inline void VideoZoomRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoZoomRequest.id)
}
inline std::string* VideoZoomRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoZoomRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.VideoZoomRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoZoomRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoZoomRequest.id)
}
inline std::string* VideoZoomRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoZoomRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoZoomRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoZoomRequest.id)
}

// -------------------------------------------------------------------

// VideoZoomReply

// string oid = 1;
inline void VideoZoomReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoZoomReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.VideoZoomReply.oid)
  return _internal_oid();
}
inline void VideoZoomReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.VideoZoomReply.oid)
}
inline std::string* VideoZoomReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoZoomReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& VideoZoomReply::_internal_oid() const {
  return oid_.Get();
}
inline void VideoZoomReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoZoomReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoZoomReply.oid)
}
inline void VideoZoomReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoZoomReply.oid)
}
inline void VideoZoomReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoZoomReply.oid)
}
inline std::string* VideoZoomReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoZoomReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.VideoZoomReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoZoomReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoZoomReply.oid)
}
inline std::string* VideoZoomReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoZoomReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoZoomReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoZoomReply.oid)
}

// string message = 2;
inline void VideoZoomReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoZoomReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.VideoZoomReply.message)
  return _internal_message();
}
inline void VideoZoomReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.VideoZoomReply.message)
}
inline std::string* VideoZoomReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoZoomReply.message)
  return _internal_mutable_message();
}
inline const std::string& VideoZoomReply::_internal_message() const {
  return message_.Get();
}
inline void VideoZoomReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoZoomReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoZoomReply.message)
}
inline void VideoZoomReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoZoomReply.message)
}
inline void VideoZoomReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoZoomReply.message)
}
inline std::string* VideoZoomReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoZoomReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.VideoZoomReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoZoomReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoZoomReply.message)
}
inline std::string* VideoZoomReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoZoomReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoZoomReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoZoomReply.message)
}

// -------------------------------------------------------------------

// VideoSlowRequest

// string method = 1;
inline void VideoSlowRequest::clear_method() {
  method_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoSlowRequest::method() const {
  // @@protoc_insertion_point(field_get:tensor.VideoSlowRequest.method)
  return _internal_method();
}
inline void VideoSlowRequest::set_method(const std::string& value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:tensor.VideoSlowRequest.method)
}
inline std::string* VideoSlowRequest::mutable_method() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoSlowRequest.method)
  return _internal_mutable_method();
}
inline const std::string& VideoSlowRequest::_internal_method() const {
  return method_.Get();
}
inline void VideoSlowRequest::_internal_set_method(const std::string& value) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSlowRequest::set_method(std::string&& value) {
  
  method_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoSlowRequest.method)
}
inline void VideoSlowRequest::set_method(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoSlowRequest.method)
}
inline void VideoSlowRequest::set_method(const char* value,
    size_t size) {
  
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoSlowRequest.method)
}
inline std::string* VideoSlowRequest::_internal_mutable_method() {
  
  return method_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSlowRequest::release_method() {
  // @@protoc_insertion_point(field_release:tensor.VideoSlowRequest.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSlowRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoSlowRequest.method)
}
inline std::string* VideoSlowRequest::unsafe_arena_release_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoSlowRequest.method)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return method_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoSlowRequest::unsafe_arena_set_allocated_method(
    std::string* method) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (method != nullptr) {
    
  } else {
    
  }
  method_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      method, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoSlowRequest.method)
}

// string id = 2;
inline void VideoSlowRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoSlowRequest::id() const {
  // @@protoc_insertion_point(field_get:tensor.VideoSlowRequest.id)
  return _internal_id();
}
inline void VideoSlowRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tensor.VideoSlowRequest.id)
}
inline std::string* VideoSlowRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoSlowRequest.id)
  return _internal_mutable_id();
}
inline const std::string& VideoSlowRequest::_internal_id() const {
  return id_.Get();
}
inline void VideoSlowRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSlowRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoSlowRequest.id)
}
inline void VideoSlowRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoSlowRequest.id)
}
inline void VideoSlowRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoSlowRequest.id)
}
inline std::string* VideoSlowRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSlowRequest::release_id() {
  // @@protoc_insertion_point(field_release:tensor.VideoSlowRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSlowRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoSlowRequest.id)
}
inline std::string* VideoSlowRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoSlowRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoSlowRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoSlowRequest.id)
}

// -------------------------------------------------------------------

// VideoSlowReply

// string oid = 1;
inline void VideoSlowReply::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoSlowReply::oid() const {
  // @@protoc_insertion_point(field_get:tensor.VideoSlowReply.oid)
  return _internal_oid();
}
inline void VideoSlowReply::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:tensor.VideoSlowReply.oid)
}
inline std::string* VideoSlowReply::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoSlowReply.oid)
  return _internal_mutable_oid();
}
inline const std::string& VideoSlowReply::_internal_oid() const {
  return oid_.Get();
}
inline void VideoSlowReply::_internal_set_oid(const std::string& value) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSlowReply::set_oid(std::string&& value) {
  
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoSlowReply.oid)
}
inline void VideoSlowReply::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoSlowReply.oid)
}
inline void VideoSlowReply::set_oid(const char* value,
    size_t size) {
  
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoSlowReply.oid)
}
inline std::string* VideoSlowReply::_internal_mutable_oid() {
  
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSlowReply::release_oid() {
  // @@protoc_insertion_point(field_release:tensor.VideoSlowReply.oid)
  return oid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSlowReply::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoSlowReply.oid)
}
inline std::string* VideoSlowReply::unsafe_arena_release_oid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoSlowReply.oid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return oid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoSlowReply::unsafe_arena_set_allocated_oid(
    std::string* oid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (oid != nullptr) {
    
  } else {
    
  }
  oid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      oid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoSlowReply.oid)
}

// string message = 2;
inline void VideoSlowReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VideoSlowReply::message() const {
  // @@protoc_insertion_point(field_get:tensor.VideoSlowReply.message)
  return _internal_message();
}
inline void VideoSlowReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:tensor.VideoSlowReply.message)
}
inline std::string* VideoSlowReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:tensor.VideoSlowReply.message)
  return _internal_mutable_message();
}
inline const std::string& VideoSlowReply::_internal_message() const {
  return message_.Get();
}
inline void VideoSlowReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VideoSlowReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:tensor.VideoSlowReply.message)
}
inline void VideoSlowReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:tensor.VideoSlowReply.message)
}
inline void VideoSlowReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:tensor.VideoSlowReply.message)
}
inline std::string* VideoSlowReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VideoSlowReply::release_message() {
  // @@protoc_insertion_point(field_release:tensor.VideoSlowReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VideoSlowReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tensor.VideoSlowReply.message)
}
inline std::string* VideoSlowReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensor.VideoSlowReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VideoSlowReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensor.VideoSlowReply.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensor

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensor_2eproto
