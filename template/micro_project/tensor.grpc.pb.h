// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensor.proto
#ifndef GRPC_tensor_2eproto__INCLUDED
#define GRPC_tensor_2eproto__INCLUDED

#include "tensor.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace tensor {

// Tensor Service
class TensorService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.TensorService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Ping, Say Hello
    virtual ::grpc::Status Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::tensor::HelloReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>> AsyncHello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>>(AsyncHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>> PrepareAsyncHello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>>(PrepareAsyncHelloRaw(context, request, cq));
    }
    // Get/Set/Del tensor
    virtual ::grpc::Status GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::tensor::GetTensorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>> AsyncGetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>>(AsyncGetTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>> PrepareAsyncGetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>>(PrepareAsyncGetTensorRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::tensor::SetTensorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>> AsyncSetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>>(AsyncSetTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>> PrepareAsyncSetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>>(PrepareAsyncSetTensorRaw(context, request, cq));
    }
    virtual ::grpc::Status DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::tensor::DelTensorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>> AsyncDelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>>(AsyncDelTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>> PrepareAsyncDelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>>(PrepareAsyncDelTensorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Ping, Say Hello
      virtual void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get/Set/Del tensor
      virtual void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>* AsyncHelloRaw(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::HelloReply>* PrepareAsyncHelloRaw(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>* AsyncGetTensorRaw(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::GetTensorReply>* PrepareAsyncGetTensorRaw(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>* AsyncSetTensorRaw(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::SetTensorReply>* PrepareAsyncSetTensorRaw(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>* AsyncDelTensorRaw(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::DelTensorReply>* PrepareAsyncDelTensorRaw(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::tensor::HelloReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>> AsyncHello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>>(AsyncHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>> PrepareAsyncHello(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>>(PrepareAsyncHelloRaw(context, request, cq));
    }
    ::grpc::Status GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::tensor::GetTensorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>> AsyncGetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>>(AsyncGetTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>> PrepareAsyncGetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>>(PrepareAsyncGetTensorRaw(context, request, cq));
    }
    ::grpc::Status SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::tensor::SetTensorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>> AsyncSetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>>(AsyncSetTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>> PrepareAsyncSetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>>(PrepareAsyncSetTensorRaw(context, request, cq));
    }
    ::grpc::Status DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::tensor::DelTensorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>> AsyncDelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>>(AsyncDelTensorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>> PrepareAsyncDelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>>(PrepareAsyncDelTensorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, std::function<void(::grpc::Status)>) override;
      void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Hello(::grpc::ClientContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Hello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, std::function<void(::grpc::Status)>) override;
      void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTensor(::grpc::ClientContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::GetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, std::function<void(::grpc::Status)>) override;
      void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetTensor(::grpc::ClientContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::SetTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, std::function<void(::grpc::Status)>) override;
      void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DelTensor(::grpc::ClientContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DelTensor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::DelTensorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>* AsyncHelloRaw(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::HelloReply>* PrepareAsyncHelloRaw(::grpc::ClientContext* context, const ::tensor::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>* AsyncGetTensorRaw(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::GetTensorReply>* PrepareAsyncGetTensorRaw(::grpc::ClientContext* context, const ::tensor::GetTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>* AsyncSetTensorRaw(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::SetTensorReply>* PrepareAsyncSetTensorRaw(::grpc::ClientContext* context, const ::tensor::SetTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>* AsyncDelTensorRaw(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::DelTensorReply>* PrepareAsyncDelTensorRaw(::grpc::ClientContext* context, const ::tensor::DelTensorRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Hello_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTensor_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTensor_;
    const ::grpc::internal::RpcMethod rpcmethod_DelTensor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Ping, Say Hello
    virtual ::grpc::Status Hello(::grpc::ServerContext* context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response);
    // Get/Set/Del tensor
    virtual ::grpc::Status GetTensor(::grpc::ServerContext* context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response);
    virtual ::grpc::Status SetTensor(::grpc::ServerContext* context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response);
    virtual ::grpc::Status DelTensor(::grpc::ServerContext* context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Hello() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHello(::grpc::ServerContext* context, ::tensor::HelloRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::HelloReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTensor() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTensor(::grpc::ServerContext* context, ::tensor::GetTensorRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::GetTensorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTensor() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTensor(::grpc::ServerContext* context, ::tensor::SetTensorRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::SetTensorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DelTensor() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelTensor(::grpc::ServerContext* context, ::tensor::DelTensorRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::DelTensorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Hello<WithAsyncMethod_GetTensor<WithAsyncMethod_SetTensor<WithAsyncMethod_DelTensor<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Hello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::HelloRequest, ::tensor::HelloReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::HelloRequest* request, ::tensor::HelloReply* response) { return this->Hello(context, request, response); }));}
    void SetMessageAllocatorFor_Hello(
        ::grpc::experimental::MessageAllocator< ::tensor::HelloRequest, ::tensor::HelloReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::HelloRequest, ::tensor::HelloReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Hello(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Hello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::GetTensorRequest, ::tensor::GetTensorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::GetTensorRequest* request, ::tensor::GetTensorReply* response) { return this->GetTensor(context, request, response); }));}
    void SetMessageAllocatorFor_GetTensor(
        ::grpc::experimental::MessageAllocator< ::tensor::GetTensorRequest, ::tensor::GetTensorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::GetTensorRequest, ::tensor::GetTensorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::SetTensorRequest, ::tensor::SetTensorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::SetTensorRequest* request, ::tensor::SetTensorReply* response) { return this->SetTensor(context, request, response); }));}
    void SetMessageAllocatorFor_SetTensor(
        ::grpc::experimental::MessageAllocator< ::tensor::SetTensorRequest, ::tensor::SetTensorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::SetTensorRequest, ::tensor::SetTensorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DelTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::DelTensorRequest, ::tensor::DelTensorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::DelTensorRequest* request, ::tensor::DelTensorReply* response) { return this->DelTensor(context, request, response); }));}
    void SetMessageAllocatorFor_DelTensor(
        ::grpc::experimental::MessageAllocator< ::tensor::DelTensorRequest, ::tensor::DelTensorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::DelTensorRequest, ::tensor::DelTensorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DelTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DelTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Hello<ExperimentalWithCallbackMethod_GetTensor<ExperimentalWithCallbackMethod_SetTensor<ExperimentalWithCallbackMethod_DelTensor<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Hello<ExperimentalWithCallbackMethod_GetTensor<ExperimentalWithCallbackMethod_SetTensor<ExperimentalWithCallbackMethod_DelTensor<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Hello() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTensor() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTensor() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DelTensor() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Hello() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHello(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTensor() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTensor() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DelTensor() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelTensor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Hello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Hello(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Hello(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Hello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTensor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTensor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DelTensor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DelTensor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DelTensor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DelTensor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Hello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Hello() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::HelloRequest, ::tensor::HelloReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::HelloRequest, ::tensor::HelloReply>* streamer) {
                       return this->StreamedHello(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Hello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Hello(::grpc::ServerContext* /*context*/, const ::tensor::HelloRequest* /*request*/, ::tensor::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHello(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::HelloRequest,::tensor::HelloReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTensor() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::GetTensorRequest, ::tensor::GetTensorReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::GetTensorRequest, ::tensor::GetTensorReply>* streamer) {
                       return this->StreamedGetTensor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTensor(::grpc::ServerContext* /*context*/, const ::tensor::GetTensorRequest* /*request*/, ::tensor::GetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::GetTensorRequest,::tensor::GetTensorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTensor() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::SetTensorRequest, ::tensor::SetTensorReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::SetTensorRequest, ::tensor::SetTensorReply>* streamer) {
                       return this->StreamedSetTensor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTensor(::grpc::ServerContext* /*context*/, const ::tensor::SetTensorRequest* /*request*/, ::tensor::SetTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::SetTensorRequest,::tensor::SetTensorReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DelTensor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DelTensor() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::DelTensorRequest, ::tensor::DelTensorReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::DelTensorRequest, ::tensor::DelTensorReply>* streamer) {
                       return this->StreamedDelTensor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DelTensor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DelTensor(::grpc::ServerContext* /*context*/, const ::tensor::DelTensorRequest* /*request*/, ::tensor::DelTensorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDelTensor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::DelTensorRequest,::tensor::DelTensorReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Hello<WithStreamedUnaryMethod_GetTensor<WithStreamedUnaryMethod_SetTensor<WithStreamedUnaryMethod_DelTensor<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Hello<WithStreamedUnaryMethod_GetTensor<WithStreamedUnaryMethod_SetTensor<WithStreamedUnaryMethod_DelTensor<Service > > > > StreamedService;
};

// Image applications
class ImageCleanService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.ImageCleanService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::tensor::ImageCleanReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>> AsyncImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>>(AsyncImageCleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>> PrepareAsyncImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>>(PrepareAsyncImageCleanRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>* AsyncImageCleanRaw(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageCleanReply>* PrepareAsyncImageCleanRaw(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::tensor::ImageCleanReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>> AsyncImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>>(AsyncImageCleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>> PrepareAsyncImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>>(PrepareAsyncImageCleanRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, std::function<void(::grpc::Status)>) override;
      void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageClean(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>* AsyncImageCleanRaw(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageCleanReply>* PrepareAsyncImageCleanRaw(::grpc::ClientContext* context, const ::tensor::ImageCleanRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ImageClean_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ImageClean(::grpc::ServerContext* context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImageClean() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageClean(::grpc::ServerContext* context, ::tensor::ImageCleanRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::ImageCleanReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ImageClean<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImageClean() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageCleanRequest, ::tensor::ImageCleanReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::ImageCleanRequest* request, ::tensor::ImageCleanReply* response) { return this->ImageClean(context, request, response); }));}
    void SetMessageAllocatorFor_ImageClean(
        ::grpc::experimental::MessageAllocator< ::tensor::ImageCleanRequest, ::tensor::ImageCleanReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageCleanRequest, ::tensor::ImageCleanReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageClean(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageClean(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ImageClean<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ImageClean<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImageClean() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImageClean() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageClean(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImageClean() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImageClean(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageClean(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageClean(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImageClean() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::ImageCleanRequest, ::tensor::ImageCleanReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::ImageCleanRequest, ::tensor::ImageCleanReply>* streamer) {
                       return this->StreamedImageClean(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImageClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageClean(::grpc::ServerContext* /*context*/, const ::tensor::ImageCleanRequest* /*request*/, ::tensor::ImageCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageClean(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::ImageCleanRequest,::tensor::ImageCleanReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ImageClean<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ImageClean<Service > StreamedService;
};

class ImageColorService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.ImageColorService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::tensor::ImageColorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>> AsyncImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>>(AsyncImageColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>> PrepareAsyncImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>>(PrepareAsyncImageColorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>* AsyncImageColorRaw(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageColorReply>* PrepareAsyncImageColorRaw(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::tensor::ImageColorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>> AsyncImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>>(AsyncImageColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>> PrepareAsyncImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>>(PrepareAsyncImageColorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, std::function<void(::grpc::Status)>) override;
      void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageColor(::grpc::ClientContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>* AsyncImageColorRaw(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageColorReply>* PrepareAsyncImageColorRaw(::grpc::ClientContext* context, const ::tensor::ImageColorRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ImageColor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ImageColor(::grpc::ServerContext* context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImageColor() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageColor(::grpc::ServerContext* context, ::tensor::ImageColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::ImageColorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ImageColor<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImageColor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageColorRequest, ::tensor::ImageColorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::ImageColorRequest* request, ::tensor::ImageColorReply* response) { return this->ImageColor(context, request, response); }));}
    void SetMessageAllocatorFor_ImageColor(
        ::grpc::experimental::MessageAllocator< ::tensor::ImageColorRequest, ::tensor::ImageColorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageColorRequest, ::tensor::ImageColorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageColor(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageColor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ImageColor<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ImageColor<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImageColor() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImageColor() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImageColor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImageColor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageColor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImageColor() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::ImageColorRequest, ::tensor::ImageColorReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::ImageColorRequest, ::tensor::ImageColorReply>* streamer) {
                       return this->StreamedImageColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImageColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageColor(::grpc::ServerContext* /*context*/, const ::tensor::ImageColorRequest* /*request*/, ::tensor::ImageColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::ImageColorRequest,::tensor::ImageColorReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ImageColor<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ImageColor<Service > StreamedService;
};

class ImageZoomService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.ImageZoomService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::tensor::ImageZoomReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>> AsyncImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>>(AsyncImageZoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>> PrepareAsyncImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>>(PrepareAsyncImageZoomRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>* AsyncImageZoomRaw(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImageZoomReply>* PrepareAsyncImageZoomRaw(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::tensor::ImageZoomReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>> AsyncImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>>(AsyncImageZoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>> PrepareAsyncImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>>(PrepareAsyncImageZoomRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, std::function<void(::grpc::Status)>) override;
      void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageZoom(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImageZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImageZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>* AsyncImageZoomRaw(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::ImageZoomReply>* PrepareAsyncImageZoomRaw(::grpc::ClientContext* context, const ::tensor::ImageZoomRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ImageZoom_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ImageZoom(::grpc::ServerContext* context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImageZoom() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageZoom(::grpc::ServerContext* context, ::tensor::ImageZoomRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::ImageZoomReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ImageZoom<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImageZoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageZoomRequest, ::tensor::ImageZoomReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::ImageZoomRequest* request, ::tensor::ImageZoomReply* response) { return this->ImageZoom(context, request, response); }));}
    void SetMessageAllocatorFor_ImageZoom(
        ::grpc::experimental::MessageAllocator< ::tensor::ImageZoomRequest, ::tensor::ImageZoomReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImageZoomRequest, ::tensor::ImageZoomReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageZoom(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageZoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ImageZoom<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ImageZoom<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImageZoom() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImageZoom() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImageZoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImageZoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImageZoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImageZoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImageZoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImageZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImageZoom() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::ImageZoomRequest, ::tensor::ImageZoomReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::ImageZoomRequest, ::tensor::ImageZoomReply>* streamer) {
                       return this->StreamedImageZoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImageZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImageZoom(::grpc::ServerContext* /*context*/, const ::tensor::ImageZoomRequest* /*request*/, ::tensor::ImageZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImageZoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::ImageZoomRequest,::tensor::ImageZoomReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ImageZoom<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ImageZoom<Service > StreamedService;
};

class ImagePatchService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.ImagePatchService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::tensor::ImagePatchReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>> AsyncImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>>(AsyncImagePatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>> PrepareAsyncImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>>(PrepareAsyncImagePatchRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>* AsyncImagePatchRaw(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::ImagePatchReply>* PrepareAsyncImagePatchRaw(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::tensor::ImagePatchReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>> AsyncImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>>(AsyncImagePatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>> PrepareAsyncImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>>(PrepareAsyncImagePatchRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, std::function<void(::grpc::Status)>) override;
      void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImagePatch(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImagePatch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::ImagePatchReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>* AsyncImagePatchRaw(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::ImagePatchReply>* PrepareAsyncImagePatchRaw(::grpc::ClientContext* context, const ::tensor::ImagePatchRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ImagePatch_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ImagePatch(::grpc::ServerContext* context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImagePatch() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImagePatch(::grpc::ServerContext* context, ::tensor::ImagePatchRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::ImagePatchReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ImagePatch<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImagePatch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImagePatchRequest, ::tensor::ImagePatchReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::ImagePatchRequest* request, ::tensor::ImagePatchReply* response) { return this->ImagePatch(context, request, response); }));}
    void SetMessageAllocatorFor_ImagePatch(
        ::grpc::experimental::MessageAllocator< ::tensor::ImagePatchRequest, ::tensor::ImagePatchReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::ImagePatchRequest, ::tensor::ImagePatchReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImagePatch(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImagePatch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ImagePatch<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ImagePatch<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImagePatch() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImagePatch() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImagePatch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImagePatch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImagePatch(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImagePatch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImagePatch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImagePatch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImagePatch() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::ImagePatchRequest, ::tensor::ImagePatchReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::ImagePatchRequest, ::tensor::ImagePatchReply>* streamer) {
                       return this->StreamedImagePatch(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImagePatch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImagePatch(::grpc::ServerContext* /*context*/, const ::tensor::ImagePatchRequest* /*request*/, ::tensor::ImagePatchReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImagePatch(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::ImagePatchRequest,::tensor::ImagePatchReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ImagePatch<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ImagePatch<Service > StreamedService;
};

// Video applications
class VideoCleanService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.VideoCleanService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::tensor::VideoCleanReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>> AsyncVideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>>(AsyncVideoCleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>> PrepareAsyncVideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>>(PrepareAsyncVideoCleanRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>* AsyncVideoCleanRaw(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoCleanReply>* PrepareAsyncVideoCleanRaw(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::tensor::VideoCleanReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>> AsyncVideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>>(AsyncVideoCleanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>> PrepareAsyncVideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>>(PrepareAsyncVideoCleanRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, std::function<void(::grpc::Status)>) override;
      void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoClean(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoClean(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoCleanReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>* AsyncVideoCleanRaw(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoCleanReply>* PrepareAsyncVideoCleanRaw(::grpc::ClientContext* context, const ::tensor::VideoCleanRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_VideoClean_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status VideoClean(::grpc::ServerContext* context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VideoClean() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoClean(::grpc::ServerContext* context, ::tensor::VideoCleanRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::VideoCleanReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_VideoClean<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VideoClean() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoCleanRequest, ::tensor::VideoCleanReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::VideoCleanRequest* request, ::tensor::VideoCleanReply* response) { return this->VideoClean(context, request, response); }));}
    void SetMessageAllocatorFor_VideoClean(
        ::grpc::experimental::MessageAllocator< ::tensor::VideoCleanRequest, ::tensor::VideoCleanReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoCleanRequest, ::tensor::VideoCleanReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoClean(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoClean(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_VideoClean<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_VideoClean<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VideoClean() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VideoClean() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoClean(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoClean() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VideoClean(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoClean(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoClean(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoClean : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VideoClean() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::VideoCleanRequest, ::tensor::VideoCleanReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::VideoCleanRequest, ::tensor::VideoCleanReply>* streamer) {
                       return this->StreamedVideoClean(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VideoClean() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoClean(::grpc::ServerContext* /*context*/, const ::tensor::VideoCleanRequest* /*request*/, ::tensor::VideoCleanReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoClean(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::VideoCleanRequest,::tensor::VideoCleanReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_VideoClean<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_VideoClean<Service > StreamedService;
};

class VideoColorService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.VideoColorService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::tensor::VideoColorReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>> AsyncVideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>>(AsyncVideoColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>> PrepareAsyncVideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>>(PrepareAsyncVideoColorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>* AsyncVideoColorRaw(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoColorReply>* PrepareAsyncVideoColorRaw(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::tensor::VideoColorReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>> AsyncVideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>>(AsyncVideoColorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>> PrepareAsyncVideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>>(PrepareAsyncVideoColorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, std::function<void(::grpc::Status)>) override;
      void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoColor(::grpc::ClientContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoColor(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoColorReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>* AsyncVideoColorRaw(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoColorReply>* PrepareAsyncVideoColorRaw(::grpc::ClientContext* context, const ::tensor::VideoColorRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_VideoColor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status VideoColor(::grpc::ServerContext* context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VideoColor() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoColor(::grpc::ServerContext* context, ::tensor::VideoColorRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::VideoColorReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_VideoColor<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VideoColor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoColorRequest, ::tensor::VideoColorReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::VideoColorRequest* request, ::tensor::VideoColorReply* response) { return this->VideoColor(context, request, response); }));}
    void SetMessageAllocatorFor_VideoColor(
        ::grpc::experimental::MessageAllocator< ::tensor::VideoColorRequest, ::tensor::VideoColorReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoColorRequest, ::tensor::VideoColorReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoColor(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoColor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_VideoColor<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_VideoColor<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VideoColor() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VideoColor() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoColor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoColor() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VideoColor(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoColor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoColor(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoColor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VideoColor() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::VideoColorRequest, ::tensor::VideoColorReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::VideoColorRequest, ::tensor::VideoColorReply>* streamer) {
                       return this->StreamedVideoColor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VideoColor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoColor(::grpc::ServerContext* /*context*/, const ::tensor::VideoColorRequest* /*request*/, ::tensor::VideoColorReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoColor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::VideoColorRequest,::tensor::VideoColorReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_VideoColor<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_VideoColor<Service > StreamedService;
};

class VideoZoomService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.VideoZoomService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::tensor::VideoZoomReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>> AsyncVideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>>(AsyncVideoZoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>> PrepareAsyncVideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>>(PrepareAsyncVideoZoomRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>* AsyncVideoZoomRaw(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoZoomReply>* PrepareAsyncVideoZoomRaw(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::tensor::VideoZoomReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>> AsyncVideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>>(AsyncVideoZoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>> PrepareAsyncVideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>>(PrepareAsyncVideoZoomRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, std::function<void(::grpc::Status)>) override;
      void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoZoom(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoZoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoZoomReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>* AsyncVideoZoomRaw(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoZoomReply>* PrepareAsyncVideoZoomRaw(::grpc::ClientContext* context, const ::tensor::VideoZoomRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_VideoZoom_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status VideoZoom(::grpc::ServerContext* context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VideoZoom() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoZoom(::grpc::ServerContext* context, ::tensor::VideoZoomRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::VideoZoomReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_VideoZoom<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VideoZoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoZoomRequest, ::tensor::VideoZoomReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::VideoZoomRequest* request, ::tensor::VideoZoomReply* response) { return this->VideoZoom(context, request, response); }));}
    void SetMessageAllocatorFor_VideoZoom(
        ::grpc::experimental::MessageAllocator< ::tensor::VideoZoomRequest, ::tensor::VideoZoomReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoZoomRequest, ::tensor::VideoZoomReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoZoom(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoZoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_VideoZoom<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_VideoZoom<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VideoZoom() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VideoZoom() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoZoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoZoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VideoZoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoZoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoZoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoZoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VideoZoom() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::VideoZoomRequest, ::tensor::VideoZoomReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::VideoZoomRequest, ::tensor::VideoZoomReply>* streamer) {
                       return this->StreamedVideoZoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VideoZoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoZoom(::grpc::ServerContext* /*context*/, const ::tensor::VideoZoomRequest* /*request*/, ::tensor::VideoZoomReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoZoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::VideoZoomRequest,::tensor::VideoZoomReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_VideoZoom<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_VideoZoom<Service > StreamedService;
};

class VideoSlowService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensor.VideoSlowService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::tensor::VideoSlowReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>> AsyncVideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>>(AsyncVideoSlowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>> PrepareAsyncVideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>>(PrepareAsyncVideoSlowRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>* AsyncVideoSlowRaw(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensor::VideoSlowReply>* PrepareAsyncVideoSlowRaw(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::tensor::VideoSlowReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>> AsyncVideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>>(AsyncVideoSlowRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>> PrepareAsyncVideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>>(PrepareAsyncVideoSlowRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, std::function<void(::grpc::Status)>) override;
      void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoSlow(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VideoSlow(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::tensor::VideoSlowReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>* AsyncVideoSlowRaw(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensor::VideoSlowReply>* PrepareAsyncVideoSlowRaw(::grpc::ClientContext* context, const ::tensor::VideoSlowRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_VideoSlow_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status VideoSlow(::grpc::ServerContext* context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VideoSlow() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoSlow(::grpc::ServerContext* context, ::tensor::VideoSlowRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensor::VideoSlowReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_VideoSlow<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VideoSlow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoSlowRequest, ::tensor::VideoSlowReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::tensor::VideoSlowRequest* request, ::tensor::VideoSlowReply* response) { return this->VideoSlow(context, request, response); }));}
    void SetMessageAllocatorFor_VideoSlow(
        ::grpc::experimental::MessageAllocator< ::tensor::VideoSlowRequest, ::tensor::VideoSlowReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::tensor::VideoSlowRequest, ::tensor::VideoSlowReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoSlow(
      ::grpc::CallbackServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoSlow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_VideoSlow<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_VideoSlow<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VideoSlow() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VideoSlow() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVideoSlow(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VideoSlow() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VideoSlow(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VideoSlow(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VideoSlow(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VideoSlow : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VideoSlow() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::tensor::VideoSlowRequest, ::tensor::VideoSlowReply>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::tensor::VideoSlowRequest, ::tensor::VideoSlowReply>* streamer) {
                       return this->StreamedVideoSlow(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VideoSlow() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VideoSlow(::grpc::ServerContext* /*context*/, const ::tensor::VideoSlowRequest* /*request*/, ::tensor::VideoSlowReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVideoSlow(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensor::VideoSlowRequest,::tensor::VideoSlowReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_VideoSlow<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_VideoSlow<Service > StreamedService;
};

}  // namespace tensor


#endif  // GRPC_tensor_2eproto__INCLUDED
